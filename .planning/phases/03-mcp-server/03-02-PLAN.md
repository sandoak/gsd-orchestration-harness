---
phase: 03-mcp-server
plan: 02
type: execute
---

<objective>
Implement session control MCP tools: gsd_start_session, gsd_list_sessions, gsd_end_session.

Purpose: Enable Claude Code to start, monitor, and terminate GSD sessions via MCP tools.
Output: Three working MCP tools for session lifecycle management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:

@.planning/phases/03-mcp-server/03-01-SUMMARY.md

# Session manager API:

@packages/session-manager/src/index.ts
@packages/session-manager/src/persistent-session-manager.ts

**Tech stack available:** @modelcontextprotocol/sdk, @gsd/session-manager (PersistentSessionManager)
**Established patterns:** Union types, typed tool parameters with zod schemas

**API Reference (PersistentSessionManager):**

- `spawn(workingDir: string, command?: string): Promise<Session>` - Start session
- `listSessions(): Session[]` - List all sessions (live + historical)
- `terminate(sessionId: string): Promise<void>` - End session
- `getSession(sessionId: string): Session | undefined` - Get single session
- `availableSlotsCount: number` - Available slots (max 3)

**MCP Tool Pattern:**

```typescript
server.tool('tool_name', { param: z.string() }, async ({ param }) => {
  // Implementation
  return { content: [{ type: 'text', text: JSON.stringify(result) }] };
});
```

</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement gsd_start_session tool</name>
  <files>packages/mcp-server/src/tools/start-session.ts, packages/mcp-server/src/server.ts</files>
  <action>
Create tools directory and implement gsd_start_session:

1. src/tools/start-session.ts:
   - Export function registerStartSessionTool(server: McpServer, manager: PersistentSessionManager)
   - Define tool with zod schema:
     - workingDir: z.string() - Required, path to project directory
     - command: z.string().optional() - Optional command to pass to Claude
   - Implementation:
     - Check manager.availableSlotsCount > 0, return error if no slots
     - Call manager.spawn(workingDir, command)
     - Return session object as JSON in text content
   - Include clear error messages for: no available slots, spawn failure

2. Update src/server.ts:
   - Import and call registerStartSessionTool in constructor
   - Pass server and manager instances

Tool name must be exactly "gsd_start_session" to match PROJECT.md spec.
Return MCP content array format: { content: [{ type: 'text', text: '...' }] }
</action>
<verify>pnpm -F @gsd/mcp-server build succeeds, tool is registered (visible in server setup)</verify>
<done>gsd_start_session tool implemented, validates inputs, starts sessions, handles errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement gsd_list_sessions and gsd_end_session tools</name>
  <files>packages/mcp-server/src/tools/list-sessions.ts, packages/mcp-server/src/tools/end-session.ts, packages/mcp-server/src/server.ts</files>
  <action>
Implement remaining session control tools:

1. src/tools/list-sessions.ts - gsd_list_sessions:
   - No required parameters
   - Optional filter: z.enum(['all', 'running', 'completed', 'failed']).default('all')
   - Call manager.listSessions()
   - Filter by status if specified
   - Return array of sessions with: id, slot, status, workingDir, currentCommand, startedAt, endedAt
   - Include availableSlots count in response

2. src/tools/end-session.ts - gsd_end_session:
   - Required parameter: sessionId: z.string()
   - Get session first to verify it exists and is running
   - Call manager.terminate(sessionId)
   - Return success confirmation with session info
   - Handle errors: session not found, session already ended

3. Update src/server.ts:
   - Import and register both tools in constructor
   - Maintain consistent registration pattern

Tool names must match PROJECT.md exactly: "gsd_list_sessions", "gsd_end_session"
</action>
<verify>pnpm -F @gsd/mcp-server build succeeds, all three session control tools registered</verify>
<done>All session control tools implemented: start, list, end. Each validates inputs and handles errors appropriately.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm -F @gsd/mcp-server build` succeeds without errors
- [ ] Three tools registered: gsd_start_session, gsd_list_sessions, gsd_end_session
- [ ] Each tool has proper zod schema validation
- [ ] Error handling covers common cases (no slots, session not found, etc.)
</verification>

<success_criteria>

- All three session control tools implemented and registered
- Tools use PersistentSessionManager API correctly
- Input validation with zod schemas
- Clear error messages for failure cases
- Ready for state/output tools in 03-03
  </success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server/03-02-SUMMARY.md`
</output>
