---
phase: 02-session-management
plan: 01
type: execute
---

<objective>
Create @gsd/session-manager package with Claude CLI process spawning, lifecycle management, and output capture.

Purpose: Enable the harness to spawn and manage Claude CLI processes, capturing their output in real-time for downstream consumers (MCP server, dashboard).
Output: Working @gsd/session-manager package with SessionManager class that can spawn, monitor, and terminate Claude sessions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency graph):

@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Key files from Phase 1:

@packages/core/src/types/session.ts
@packages/core/src/types/events.ts
@packages/core/src/constants.ts
@package.json
@tsconfig.base.json

**Tech stack available:**

- pnpm workspaces with @gsd/\* path aliases
- TypeScript strict mode, NodeNext module resolution
- Vitest for testing

**Established patterns:**

- Discriminated unions for type-safe event handling
- ESM exports with .js extensions
- Composite TypeScript projects extending tsconfig.base.json

**Constraining decisions:**

- [01-01]: pnpm workspaces, NodeNext modules, @gsd/\* aliases
- [01-02]: Union types over enums, type-only @gsd/core package
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create @gsd/session-manager package structure</name>
  <files>packages/session-manager/package.json, packages/session-manager/tsconfig.json, packages/session-manager/src/index.ts, tsconfig.json</files>
  <action>
Create @gsd/session-manager package following established monorepo patterns:

1. packages/session-manager/package.json:
   - name: "@gsd/session-manager"
   - version: "0.1.0"
   - type: "module"
   - main: "dist/index.js"
   - types: "dist/index.d.ts"
   - exports with .js extensions for ESM
   - scripts: build (tsc), dev (tsc -w), type-check (tsc --noEmit)
   - dependencies: @gsd/core (workspace:\*)
   - devDependencies: typescript

2. packages/session-manager/tsconfig.json:
   - extends: "../../tsconfig.base.json"
   - compilerOptions.outDir: "./dist"
   - compilerOptions.rootDir: "./src"
   - compilerOptions.composite: true
   - include: ["src/**/*"]
   - references: [{ "path": "../core" }]

3. packages/session-manager/src/index.ts:
   - Empty placeholder with comment: "// Session manager exports"

4. Update root tsconfig.json:
   - Add reference to packages/session-manager

Run pnpm install after creating package.json to link workspace dependencies.

AVOID: Do NOT add runtime dependencies beyond @gsd/core yet - we'll add them in task 2 when implementing SessionManager.
</action>
<verify>pnpm install succeeds, pnpm -r build succeeds, packages/session-manager/dist/index.js exists</verify>
<done>Package structure created, builds successfully, workspace dependency on @gsd/core resolved</done>
</task>

<task type="auto">
  <name>Task 2: Implement SessionManager class with process spawning</name>
  <files>packages/session-manager/src/session-manager.ts, packages/session-manager/src/index.ts</files>
  <action>
Create SessionManager class that manages Claude CLI process lifecycle:

1. packages/session-manager/src/session-manager.ts:

```typescript
import { spawn, ChildProcess } from 'node:child_process';
import { EventEmitter } from 'node:events';
import type {
  Session,
  SessionStatus,
  SessionEvent,
  SessionStartedEvent,
  SessionOutputEvent,
  SessionCompletedEvent,
  SessionFailedEvent,
} from '@gsd/core';
import { MAX_SESSIONS, SESSION_SLOTS, DEFAULT_OUTPUT_BUFFER_SIZE } from '@gsd/core';
```

Class structure:

- Extends EventEmitter for typed event emission
- Private Map<string, { session: Session; process: ChildProcess; outputBuffer: string[] }>
- Private Set<1|2|3> for available slots

Methods:

- `spawn(workingDir: string, command?: string): Promise<Session>` - Spawns Claude CLI, assigns slot, returns session
- `terminate(sessionId: string): Promise<void>` - Kills process, cleans up
- `getSession(sessionId: string): Session | undefined` - Returns session by ID
- `listSessions(): Session[]` - Returns all active sessions
- `getOutput(sessionId: string): string[]` - Returns buffered output

Implementation details for spawn():

- Check for available slot (error if all 3 occupied)
- Generate UUID for sessionId (use crypto.randomUUID())
- Spawn: `spawn('claude', [command || ''], { cwd: workingDir, shell: true })`
- Attach stdout/stderr handlers that emit SessionOutputEvent
- Attach 'exit' handler that emits SessionCompletedEvent or SessionFailedEvent
- Attach 'error' handler for spawn failures
- Buffer output in memory (ring buffer, trim to DEFAULT_OUTPUT_BUFFER_SIZE)
- Return session object immediately after spawn

Event emission pattern:

- emit('session:started', event: SessionStartedEvent)
- emit('session:output', event: SessionOutputEvent)
- emit('session:completed', event: SessionCompletedEvent)
- emit('session:failed', event: SessionFailedEvent)

2. Update packages/session-manager/src/index.ts:

- Export SessionManager class
- Re-export relevant types from @gsd/core

AVOID:

- Don't use node-pty yet - standard child_process is sufficient for MVP
- Don't implement checkpoint detection here - that's Phase 5
- Don't persist to database here - that's plan 02-02
  </action>
  <verify>pnpm -r build succeeds with no TypeScript errors</verify>
  <done>SessionManager class implemented with spawn, terminate, getSession, listSessions, getOutput methods. Event emission working for all session lifecycle events.</done>
  </task>

<task type="auto">
  <name>Task 3: Add unit tests for SessionManager</name>
  <files>packages/session-manager/vitest.config.ts, packages/session-manager/src/session-manager.test.ts, packages/session-manager/package.json</files>
  <action>
Set up Vitest and write unit tests for SessionManager:

1. packages/session-manager/vitest.config.ts:

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
  },
});
```

2. Update packages/session-manager/package.json:

- Add to devDependencies: vitest
- Add script: "test": "vitest run"

3. packages/session-manager/src/session-manager.test.ts:

Test cases:

- `spawn() assigns available slot and returns session` - Spawn with simple command (echo), verify session returned with slot 1-3
- `spawn() emits session:started event` - Listen for event, verify structure matches SessionStartedEvent
- `spawn() captures stdout in output buffer` - Spawn echo command, verify getOutput() returns captured text
- `spawn() emits session:completed on process exit` - Wait for exit, verify event emitted
- `spawn() throws when all slots occupied` - Spawn 3 sessions, verify 4th throws error
- `terminate() kills process and frees slot` - Spawn, terminate, verify slot available for new spawn
- `listSessions() returns all active sessions` - Spawn 2, verify list length 2
- `getSession() returns undefined for unknown ID` - Query random ID, verify undefined

Use simple shell commands for testing (echo, sleep, etc.) to avoid needing actual Claude CLI.

AVOID: Don't mock child_process - use real process spawning with simple commands for realistic tests.
</action>
<verify>pnpm --filter @gsd/session-manager test passes all tests</verify>
<done>All 8 test cases pass, covering spawn, terminate, event emission, slot management, and output capture</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm install` succeeds
- [ ] `pnpm -r build` succeeds with no errors
- [ ] `pnpm --filter @gsd/session-manager test` passes all tests
- [ ] `pnpm -r type-check` passes
- [ ] SessionManager can spawn a process and capture its output
</verification>

<success_criteria>

- @gsd/session-manager package created and builds
- SessionManager class with spawn, terminate, getSession, listSessions, getOutput
- Event emission for session:started, session:output, session:completed, session:failed
- Slot management limiting to MAX_SESSIONS (3) concurrent sessions
- Output buffering with ring buffer behavior
- All unit tests passing
  </success_criteria>

<output>
After completion, create `.planning/phases/02-session-management/02-01-SUMMARY.md` following the summary template.
</output>
