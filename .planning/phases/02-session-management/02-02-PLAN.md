---
phase: 02-session-management
plan: 02
type: execute
---

<objective>
Implement SQLite persistence layer for sessions and output using better-sqlite3.

Purpose: Persist session metadata and output to disk so data survives harness restarts and can be queried by MCP tools and dashboard.
Output: SessionStore and OutputStore classes with full CRUD operations backed by SQLite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries:

@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-session-management/02-01-SUMMARY.md (if exists after 02-01 execution)

# Key files:

@packages/core/src/types/session.ts
@packages/core/src/types/events.ts
@packages/session-manager/src/session-manager.ts

**Tech stack available:**

- pnpm workspaces, TypeScript strict mode
- @gsd/core types (Session, SessionOutput, SessionStatus)
- @gsd/session-manager with SessionManager class

**Established patterns:**

- Discriminated unions for type-safe handling
- ESM exports with .js extensions
- Composite TypeScript projects

**Constraining decisions:**

- [01-02]: Union types over enums
- better-sqlite3 chosen for sync API (simpler than async alternatives)
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Set up SQLite database with schema</name>
  <files>packages/session-manager/src/db/database.ts, packages/session-manager/src/db/schema.sql, packages/session-manager/package.json</files>
  <action>
Add better-sqlite3 and create database initialization:

1. Update packages/session-manager/package.json:
   - Add dependency: "better-sqlite3": "^11.0.0"
   - Add devDependency: "@types/better-sqlite3": "^7.6.0"

Run `pnpm install` after updating package.json.

2. packages/session-manager/src/db/schema.sql (for documentation, embedded in code):

```sql
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  slot INTEGER NOT NULL CHECK (slot IN (1, 2, 3)),
  status TEXT NOT NULL CHECK (status IN ('idle', 'running', 'waiting_checkpoint', 'completed', 'failed')),
  working_dir TEXT NOT NULL,
  current_command TEXT,
  started_at TEXT NOT NULL,
  ended_at TEXT,
  pid INTEGER,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS session_outputs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  timestamp TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('stdout', 'stderr')),
  data TEXT NOT NULL,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_outputs_session_id ON session_outputs(session_id);
CREATE INDEX IF NOT EXISTS idx_outputs_timestamp ON session_outputs(session_id, timestamp);
```

3. packages/session-manager/src/db/database.ts:

```typescript
import Database from 'better-sqlite3';
import { join } from 'node:path';
import { existsSync, mkdirSync } from 'node:fs';
```

Class: DatabaseConnection

- Constructor takes optional dbPath (defaults to ~/.gsd-harness/sessions.db)
- Creates directory if not exists
- Opens database with WAL mode for better concurrency
- Runs schema creation on init
- Exposes db instance for stores to use
- close() method for cleanup

Singleton pattern: export default instance, but also export class for testing with custom paths.

AVOID:

- Don't use ORM - raw SQL with better-sqlite3 is simpler and faster
- Don't enable foreign_keys pragma (SQLite default) - we handle cascades manually for flexibility
  </action>
  <verify>pnpm -r build succeeds, database file can be created, schema tables exist</verify>
  <done>better-sqlite3 installed, DatabaseConnection class creates and initializes SQLite database with sessions and session_outputs tables</done>
  </task>

<task type="auto">
  <name>Task 2: Implement SessionStore for session persistence</name>
  <files>packages/session-manager/src/db/session-store.ts</files>
  <action>
Create SessionStore class for session CRUD:

packages/session-manager/src/db/session-store.ts:

```typescript
import type { Session, SessionStatus } from '@gsd/core';
import type Database from 'better-sqlite3';
```

Class: SessionStore

- Constructor takes Database instance

Methods:

- `create(session: Session): void` - INSERT session record
- `get(id: string): Session | undefined` - SELECT by ID, map to Session type
- `update(id: string, updates: Partial<Pick<Session, 'status' | 'currentCommand' | 'endedAt' | 'pid'>>): void` - UPDATE fields
- `delete(id: string): void` - DELETE by ID
- `list(): Session[]` - SELECT all, map to Session[]
- `listByStatus(status: SessionStatus): Session[]` - SELECT WHERE status
- `findRunning(): Session[]` - SELECT WHERE status IN ('running', 'waiting_checkpoint')

Implementation notes:

- Use prepared statements for all queries (better-sqlite3 caches them)
- Map snake_case DB columns to camelCase Session properties
- Parse ISO date strings back to Date objects
- Slot stored as INTEGER, cast to literal union type

AVOID:

- Don't throw on get() returning undefined - return undefined and let caller decide
- Don't auto-update updated_at in code - let SQLite trigger handle it (or skip if no trigger)
  </action>
  <verify>pnpm -r build succeeds, no TypeScript errors</verify>
  <done>SessionStore with create, get, update, delete, list, listByStatus, findRunning methods all implemented and type-safe</done>
  </task>

<task type="auto">
  <name>Task 3: Implement OutputStore for output persistence</name>
  <files>packages/session-manager/src/db/output-store.ts, packages/session-manager/src/db/index.ts, packages/session-manager/src/index.ts</files>
  <action>
Create OutputStore class and wire up exports:

1. packages/session-manager/src/db/output-store.ts:

```typescript
import type { SessionOutput } from '@gsd/core';
import type Database from 'better-sqlite3';
```

Class: OutputStore

- Constructor takes Database instance

Methods:

- `append(output: SessionOutput): void` - INSERT output record
- `getBySession(sessionId: string, limit?: number): SessionOutput[]` - SELECT by session, newest first, optional limit
- `getBySessionSince(sessionId: string, since: Date): SessionOutput[]` - SELECT newer than timestamp
- `deleteBySession(sessionId: string): void` - DELETE all outputs for session
- `getFullOutput(sessionId: string): string` - SELECT all, join data fields, return as single string

Implementation notes:

- Use prepared statements
- Map snake_case to camelCase
- ORDER BY timestamp DESC for getBySession (most recent first)
- ORDER BY timestamp ASC for getFullOutput (chronological)
- For getFullOutput, concatenate with newlines between entries

2. packages/session-manager/src/db/index.ts:

- Export DatabaseConnection (default and named)
- Export SessionStore
- Export OutputStore

3. Update packages/session-manager/src/index.ts:

- Export SessionManager
- Export { DatabaseConnection, SessionStore, OutputStore } from './db/index.js'
- Re-export relevant types

AVOID:

- Don't load entire output history into memory for large sessions - use pagination/limits
- Don't store output as BLOB - TEXT is fine for terminal output
  </action>
  <verify>pnpm -r build succeeds, pnpm -r type-check passes</verify>
  <done>OutputStore with append, getBySession, getBySessionSince, deleteBySession, getFullOutput methods. All database classes exported from package.</done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm install` succeeds (better-sqlite3 installed)
- [ ] `pnpm -r build` succeeds with no errors
- [ ] `pnpm -r type-check` passes
- [ ] Database file created in expected location
- [ ] Schema tables (sessions, session_outputs) exist
</verification>

<success_criteria>

- better-sqlite3 installed and working
- DatabaseConnection initializes SQLite with proper schema
- SessionStore with full CRUD for Session records
- OutputStore with append/query for SessionOutput records
- All classes exported from @gsd/session-manager
- Type-safe mapping between DB columns and TypeScript types
  </success_criteria>

<output>
After completion, create `.planning/phases/02-session-management/02-02-SUMMARY.md` following the summary template.
</output>
