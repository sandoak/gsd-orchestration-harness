---
phase: 02-session-management
plan: 03
type: execute
---

<objective>
Integrate SessionManager with persistence layer and implement startup recovery for orphaned sessions.

Purpose: Wire SessionManager events to persist data automatically, and handle graceful recovery when the harness restarts while sessions were running.
Output: Fully integrated session management with automatic persistence and startup recovery logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries:

@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-session-management/02-01-SUMMARY.md (after execution)
@.planning/phases/02-session-management/02-02-SUMMARY.md (after execution)

# Key files:

@packages/session-manager/src/session-manager.ts
@packages/session-manager/src/db/session-store.ts
@packages/session-manager/src/db/output-store.ts
@packages/session-manager/src/db/database.ts

**Tech stack available:**

- SessionManager with event emission
- SessionStore and OutputStore for SQLite persistence
- @gsd/core types

**Established patterns:**

- EventEmitter for session lifecycle events
- Prepared statements for database operations

**Constraining decisions:**

- [02-01]: SessionManager emits events but doesn't persist directly
- [02-02]: SQLite stores with synchronous API
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create PersistentSessionManager that wires events to storage</name>
  <files>packages/session-manager/src/persistent-session-manager.ts</files>
  <action>
Create PersistentSessionManager class that wraps SessionManager with automatic persistence:

packages/session-manager/src/persistent-session-manager.ts:

```typescript
import { SessionManager } from './session-manager.js';
import { DatabaseConnection } from './db/database.js';
import { SessionStore } from './db/session-store.js';
import { OutputStore } from './db/output-store.js';
import type { Session, SessionEvent } from '@gsd/core';
```

Class: PersistentSessionManager

- Constructor takes optional dbPath (passed to DatabaseConnection)
- Creates DatabaseConnection, SessionStore, OutputStore
- Creates internal SessionManager instance
- Wires event listeners to persist data

Event wiring:

- `session:started` → sessionStore.create(session)
- `session:output` → outputStore.append(output)
- `session:completed` → sessionStore.update(id, { status: 'completed', endedAt })
- `session:failed` → sessionStore.update(id, { status: 'failed', endedAt })

Delegate methods (pass through to internal SessionManager):

- `spawn(workingDir, command)` → calls inner spawn, returns Promise<Session>
- `terminate(sessionId)` → calls inner terminate, updates store
- `getSession(sessionId)` → returns from inner SessionManager (live) or store (completed)
- `listSessions()` → merge live sessions with completed from store
- `getOutput(sessionId)` → try inner buffer first, fall back to store

Additional methods:

- `getHistoricalSessions(limit?: number)` → sessionStore.list() with optional limit
- `close()` → close database connection, terminate any running sessions

Forward events from inner SessionManager to outer (re-emit on 'this').

AVOID:

- Don't duplicate session state - inner SessionManager is source of truth for live sessions
- Don't query database for live session data - use SessionManager directly
  </action>
  <verify>pnpm -r build succeeds, no TypeScript errors</verify>
  <done>PersistentSessionManager implemented with event-driven persistence, delegating to inner SessionManager for live operations</done>
  </task>

<task type="auto">
  <name>Task 2: Implement startup recovery for orphaned sessions</name>
  <files>packages/session-manager/src/persistent-session-manager.ts, packages/session-manager/src/recovery.ts</files>
  <action>
Add recovery logic to handle sessions that were "running" when harness crashed:

1. packages/session-manager/src/recovery.ts:

```typescript
import type { SessionStore } from './db/session-store.js';
import type { Session } from '@gsd/core';
```

Function: `recoverOrphanedSessions(sessionStore: SessionStore): RecoveryResult`

Logic:

- Query sessionStore.findRunning() to get sessions with status 'running' or 'waiting_checkpoint'
- For each: check if PID still exists (`process.kill(pid, 0)` throws if process doesn't exist)
- If process doesn't exist: mark as failed with endedAt = now, add to orphaned list
- If process exists: we can't reconnect to it (Claude CLI limitation), still mark as failed
- Return: { orphanedCount: number, recoveredSessions: Session[] }

Note: True reconnection to running Claude CLI processes is not feasible - they run in interactive mode and we've lost the stdin handle. MVP approach is to mark them failed and let user restart.

2. Update PersistentSessionManager constructor:

- Add `autoRecover: boolean = true` option
- If autoRecover: call recoverOrphanedSessions on construction
- Emit `recovery:complete` event with RecoveryResult
- Log recovery result (how many orphaned sessions marked failed)

Type addition to @gsd/core or local:

```typescript
interface RecoveryResult {
  orphanedCount: number;
  markedFailed: string[]; // session IDs
}
```

AVOID:

- Don't try to kill orphaned processes - they may have exited cleanly, we just didn't record it
- Don't attempt process reconnection - it's not reliably possible with child_process
  </action>
  <verify>pnpm -r build succeeds, recovery logic handles orphaned sessions correctly</verify>
  <done>Recovery module implemented, PersistentSessionManager performs auto-recovery on startup, orphaned sessions marked as failed</done>
  </task>

<task type="auto">
  <name>Task 3: Add integration tests for full workflow</name>
  <files>packages/session-manager/src/persistent-session-manager.test.ts, packages/session-manager/src/index.ts</files>
  <action>
Write integration tests and finalize exports:

1. packages/session-manager/src/persistent-session-manager.test.ts:

Test cases:

- `spawn() persists session to database` - Spawn, query store directly, verify session record exists
- `output is persisted as events arrive` - Spawn echo command, wait, verify outputStore has records
- `completed sessions are updated in store` - Spawn, wait for exit, verify status='completed' in store
- `recovery marks orphaned sessions as failed` - Insert fake "running" session, create new manager, verify marked failed
- `getOutput() returns historical output for completed sessions` - Complete a session, query output, verify data
- `listSessions() includes both live and completed` - Spawn one, complete one, list should show both

Use temp directory for test database (different path per test to avoid conflicts).

2. Update packages/session-manager/src/index.ts:

- Export PersistentSessionManager as primary export
- Export SessionManager for advanced use cases
- Export DatabaseConnection, SessionStore, OutputStore
- Export recoverOrphanedSessions function
- Export RecoveryResult type

Final package API:

```typescript
import { PersistentSessionManager } from '@gsd/session-manager';

const manager = new PersistentSessionManager({ dbPath: '/path/to/db' });
const session = await manager.spawn('/project', 'echo hello');
manager.on('session:output', (event) => console.log(event.data));
```

AVOID:

- Don't run tests in parallel if they share database - use unique temp paths
- Don't leave test databases behind - clean up in afterEach
  </action>
  <verify>pnpm --filter @gsd/session-manager test passes all tests (unit + integration)</verify>
  <done>Integration tests pass, PersistentSessionManager exported as primary API, Phase 2 complete</done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm install` succeeds
- [ ] `pnpm -r build` succeeds with no errors
- [ ] `pnpm --filter @gsd/session-manager test` passes all tests
- [ ] `pnpm -r type-check` passes
- [ ] End-to-end workflow works: spawn → capture output → persist → retrieve from store
- [ ] Recovery correctly handles orphaned sessions
</verification>

<success_criteria>

- PersistentSessionManager integrates SessionManager with persistence layer
- Events automatically trigger database writes
- Startup recovery marks orphaned sessions as failed
- Integration tests verify full workflow
- Package exports clean public API
- Phase 2 complete - ready for Phase 3 (MCP Server)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-session-management/02-03-SUMMARY.md` following the summary template.

This completes Phase 2: Session Management.
</output>
