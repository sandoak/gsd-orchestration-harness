---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Create the shared types package with core interfaces for GSD session management.

Purpose: Define the type contracts that all packages will use - sessions, GSD state, checkpoints, events.
Output: Published @gsd/core package with TypeScript interfaces and utility types.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**From PROJECT.md - Key types needed:**

- Session (id, status, workingDir, output buffer)
- GSD State (phase, plan, checkpoint info)
- Checkpoint types (human-verify, decision, human-action)
- MCP tool responses

**Package structure:**

```
packages/core/
├── package.json
├── tsconfig.json
├── src/
│   ├── index.ts          # Re-exports all types
│   ├── types/
│   │   ├── session.ts    # Session-related types
│   │   ├── gsd-state.ts  # GSD parsing types
│   │   ├── checkpoint.ts # Checkpoint types
│   │   └── events.ts     # Event types for streaming
│   └── constants.ts      # Shared constants
└── dist/                 # Built output
```

</context>

<tasks>

<task type="auto">
  <name>Task 1: Create packages/core package structure</name>
  <files>packages/core/package.json, packages/core/tsconfig.json, packages/core/src/index.ts</files>
  <action>
    1. Create packages/core/ directory structure

    2. Create packages/core/package.json:
       - name: "@gsd/core"
       - version: "0.1.0"
       - type: "module"
       - main: "dist/index.js"
       - types: "dist/index.d.ts"
       - exports with proper ESM structure:
         ".": { "types": "./dist/index.d.ts", "import": "./dist/index.js" }
       - scripts: build, dev, type-check
       - files: ["dist"]

    3. Create packages/core/tsconfig.json:
       - extends: "../../tsconfig.base.json"
       - compilerOptions.outDir: "dist"
       - compilerOptions.rootDir: "src"
       - compilerOptions.composite: true
       - include: ["src/**/*"]

    4. Create src/index.ts with placeholder export

    5. Run pnpm install from root to link workspace

    Avoid: Don't use "main" pointing to src - always point to dist.
    Avoid: Don't forget the "types" export in exports map.

  </action>
  <verify>
    - pnpm install succeeds
    - pnpm -F @gsd/core build runs (may fail until src populated)
    - packages/core appears in pnpm list
  </verify>
  <done>
    - packages/core package created with proper structure
    - Package linked in workspace
    - Build script configured
  </done>
</task>

<task type="auto">
  <name>Task 2: Define core type interfaces</name>
  <files>packages/core/src/types/session.ts, packages/core/src/types/gsd-state.ts, packages/core/src/types/checkpoint.ts, packages/core/src/types/events.ts</files>
  <action>
    1. Create packages/core/src/types/session.ts:
       ```typescript
       export type SessionStatus = 'idle' | 'running' | 'waiting_checkpoint' | 'completed' | 'failed';

       export interface Session {
         id: string;
         slot: 1 | 2 | 3;
         status: SessionStatus;
         workingDir: string;
         currentCommand?: string;
         startedAt: Date;
         endedAt?: Date;
         pid?: number;
       }

       export interface SessionOutput {
         sessionId: string;
         timestamp: Date;
         type: 'stdout' | 'stderr';
         data: string;
       }
       ```

    2. Create packages/core/src/types/gsd-state.ts:
       ```typescript
       export interface GsdPhase {
         number: number;
         name: string;
         status: 'not_started' | 'in_progress' | 'completed';
         plansTotal: number;
         plansComplete: number;
       }

       export interface GsdPlan {
         phase: number;
         plan: number;
         name: string;
         status: 'pending' | 'executing' | 'completed';
         tasksTotal: number;
         tasksComplete: number;
       }

       export interface GsdState {
         projectName: string;
         currentPhase: number;
         currentPlan: number;
         phases: GsdPhase[];
         hasCheckpoint: boolean;
         checkpoint?: CheckpointInfo;
       }
       ```

    3. Create packages/core/src/types/checkpoint.ts:
       ```typescript
       export type CheckpointType = 'human-verify' | 'decision' | 'human-action';

       export interface CheckpointBase {
         type: CheckpointType;
         sessionId: string;
         detectedAt: Date;
       }

       export interface HumanVerifyCheckpoint extends CheckpointBase {
         type: 'human-verify';
         whatBuilt: string;
         howToVerify: string[];
         resumeSignal: string;
       }

       export interface DecisionCheckpoint extends CheckpointBase {
         type: 'decision';
         decision: string;
         context: string;
         options: Array<{
           id: string;
           name: string;
           pros: string;
           cons: string;
         }>;
         resumeSignal: string;
       }

       export interface HumanActionCheckpoint extends CheckpointBase {
         type: 'human-action';
         action: string;
         instructions: string;
         resumeSignal: string;
       }

       export type CheckpointInfo = HumanVerifyCheckpoint | DecisionCheckpoint | HumanActionCheckpoint;
       ```

    4. Create packages/core/src/types/events.ts:
       ```typescript
       export type EventType =
         | 'session:started'
         | 'session:output'
         | 'session:checkpoint'
         | 'session:completed'
         | 'session:failed';

       export interface BaseEvent {
         type: EventType;
         timestamp: Date;
         sessionId: string;
       }

       export interface SessionStartedEvent extends BaseEvent {
         type: 'session:started';
         slot: 1 | 2 | 3;
         workingDir: string;
         command: string;
       }

       export interface SessionOutputEvent extends BaseEvent {
         type: 'session:output';
         stream: 'stdout' | 'stderr';
         data: string;
       }

       export interface SessionCheckpointEvent extends BaseEvent {
         type: 'session:checkpoint';
         checkpoint: CheckpointInfo;
       }

       export interface SessionCompletedEvent extends BaseEvent {
         type: 'session:completed';
         exitCode: number;
       }

       export interface SessionFailedEvent extends BaseEvent {
         type: 'session:failed';
         error: string;
       }

       export type SessionEvent =
         | SessionStartedEvent
         | SessionOutputEvent
         | SessionCheckpointEvent
         | SessionCompletedEvent
         | SessionFailedEvent;
       ```

    Avoid: Don't use enums - union types are more flexible and tree-shake better.
    Avoid: Don't add implementation code - this package is types only.

  </action>
  <verify>
    - All type files created
    - No TypeScript errors in files
    - Types use proper discriminated unions
  </verify>
  <done>
    - Session types defined
    - GSD state types defined
    - Checkpoint types defined with discriminated unions
    - Event types defined for streaming
  </done>
</task>

<task type="auto">
  <name>Task 3: Export types and build package</name>
  <files>packages/core/src/index.ts, packages/core/src/constants.ts</files>
  <action>
    1. Create packages/core/src/constants.ts:
       ```typescript
       export const MAX_SESSIONS = 3;
       export const SESSION_SLOTS = [1, 2, 3] as const;
       export const DEFAULT_OUTPUT_BUFFER_SIZE = 50000; // ~50KB
       export const CHECKPOINT_PATTERNS = {
         humanVerify: /CHECKPOINT:\s*human-verify/i,
         decision: /CHECKPOINT:\s*decision/i,
         humanAction: /CHECKPOINT:\s*human-action/i,
       } as const;
       ```

    2. Update packages/core/src/index.ts to re-export everything:
       ```typescript
       // Types
       export * from './types/session.js';
       export * from './types/gsd-state.js';
       export * from './types/checkpoint.js';
       export * from './types/events.js';

       // Constants
       export * from './constants.js';
       ```

    3. Build the package:
       - pnpm -F @gsd/core build

    4. Update root tsconfig.json references to include core package

    5. Verify other packages can import from @gsd/core (will be needed in Phase 2)

    Avoid: Don't forget .js extensions in imports (required for ESM).
    Avoid: Don't use barrel files for types if it causes import issues.

  </action>
  <verify>
    - pnpm -F @gsd/core build succeeds
    - dist/ contains .js and .d.ts files
    - pnpm -F @gsd/core type-check passes
    - Types are exported from index
  </verify>
  <done>
    - All types exported from index.ts
    - Package builds successfully
    - Type declarations generated
    - Ready for use by other packages
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pnpm -F @gsd/core build succeeds
- [ ] packages/core/dist/ contains index.js and index.d.ts
- [ ] pnpm -r type-check passes
- [ ] All type interfaces are exported
- [ ] Constants are exported
</verification>

<success_criteria>

- @gsd/core package created and builds
- All core types defined (Session, GsdState, Checkpoint, Events)
- Types use discriminated unions for type safety
- Package ready to be consumed by mcp-server, web-server packages
- Phase 1 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`

Since this is the final plan in Phase 1, the summary should note:

- Phase 1 complete
- Ready for Phase 2: Session Management
  </output>
