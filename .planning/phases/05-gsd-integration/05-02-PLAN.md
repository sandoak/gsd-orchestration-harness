---
phase: 05-gsd-integration
plan: 02
type: execute
---

<objective>
Parse checkpoint XML content into structured CheckpointInfo objects.

Purpose: Transform raw checkpoint output into typed, parsed data that orchestrators can act on programmatically.
Output: CheckpointParser class in @gsd/core, integrated into gsd_get_checkpoint MCP tool.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gsd-integration/05-CONTEXT.md

# Prior work providing checkpoint patterns:

@.planning/phases/03-mcp-server/03-03-SUMMARY.md

# Existing code to enhance:

@packages/core/src/types/checkpoint.ts
@packages/core/src/constants.ts
@packages/mcp-server/src/tools/get-checkpoint.ts

**Tech stack available:** TypeScript, regex, @gsd/core types
**Established patterns:** CHECKPOINT_PATTERNS for detection, extractCheckpointContent() for raw content
**Constraining decisions:**

- [03-03]: Return raw checkpoint content for Phase 5 to parse with XML
- [03-03]: Use CHECKPOINT_PATTERNS from @gsd/core for type detection
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create CheckpointParser class in @gsd/core</name>
  <files>packages/core/src/checkpoint-parser.ts, packages/core/src/index.ts</files>
  <action>
Create CheckpointParser class that parses raw checkpoint content into CheckpointInfo:

1. **human-verify checkpoints** - Parse XML-like structure:

   ```
   CHECKPOINT: human-verify
   ════════════════════════════════════════
   Task [X] of [Y]: [Name]

   What was built: [content]

   How to verify:
   1. [step]
   2. [step]
   ...

   Type "approved" to continue, or describe issues
   ════════════════════════════════════════
   ```

   Extract: whatBuilt (string), howToVerify (string[]), resumeSignal (string)

2. **decision checkpoints** - Parse:

   ```
   CHECKPOINT: decision
   ════════════════════════════════════════
   Decision: [what needs deciding]
   Context: [why this matters]

   Options:
   - option-a: [name] - Pros: [pros] Cons: [cons]
   - option-b: [name] - Pros: [pros] Cons: [cons]

   Select: option-a or option-b
   ════════════════════════════════════════
   ```

   Extract: decision, context, options[], resumeSignal

3. **human-action checkpoints** - Parse:

   ```
   CHECKPOINT: human-action
   ════════════════════════════════════════
   Action required: [action]

   Instructions:
   [multi-line instructions]

   Type "done" when completed
   ════════════════════════════════════════
   ```

   Extract: action, instructions, resumeSignal

Implementation notes:

- Use regex patterns to extract sections between delimiters
- Handle variations in formatting (extra whitespace, missing sections)
- Return undefined for fields that can't be parsed
- CHECKPOINT_PATTERNS already detect type, this parses content
  </action>
  <verify>TypeScript compiles: `pnpm --filter @gsd/core build`</verify>
  <done>CheckpointParser.parse(rawContent, type) returns HumanVerifyCheckpoint | DecisionCheckpoint | HumanActionCheckpoint</done>
  </task>

<task type="auto">
  <name>Task 2: Integrate CheckpointParser into gsd_get_checkpoint tool</name>
  <files>packages/mcp-server/src/tools/get-checkpoint.ts</files>
  <action>
Replace raw content return with parsed CheckpointInfo:

1. Import CheckpointParser from @gsd/core
2. After detecting checkpoint type and extracting raw content:
   - Call CheckpointParser.parse(rawContent, checkpointType)
   - Return full CheckpointInfo object instead of BasicCheckpointInfo
3. Update return structure:
   ```typescript
   {
     success: true,
     sessionId,
     checkpoint: {
       hasCheckpoint: true,
       type: 'human-verify',
       // Full parsed content:
       whatBuilt: '...',
       howToVerify: ['step1', 'step2'],
       resumeSignal: 'Type "approved"...',
       detectedAt: new Date(),
       sessionId
     }
   }
   ```
4. Keep rawContent as fallback if parsing fails

Remove BasicCheckpointInfo interface (use CheckpointInfo from @gsd/core).
</action>
<verify>Build succeeds: `pnpm build` from root</verify>
<done>gsd_get_checkpoint returns parsed CheckpointInfo with all typed fields</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] @gsd/core exports CheckpointParser
- [ ] gsd_get_checkpoint returns full CheckpointInfo objects
</verification>

<success_criteria>

- CheckpointParser created in @gsd/core
- Parser handles all three checkpoint types
- gsd_get_checkpoint tool returns parsed CheckpointInfo
- Build passes without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-integration/05-02-SUMMARY.md`
</output>
