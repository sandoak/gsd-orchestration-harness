---
phase: 05-gsd-integration
plan: 03
type: execute
---

<objective>
Enable checkpoint response relay via MCP tool.

Purpose: Complete the orchestration loop - orchestrator polls for checkpoints via MCP, then sends responses via MCP tool that writes to CLI stdin.
Output: sendInput() method on SessionManager, gsd_respond_checkpoint MCP tool.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gsd-integration/05-CONTEXT.md

# Prior work providing MCP infrastructure:

@.planning/phases/03-mcp-server/03-03-SUMMARY.md

# Existing code to extend:

@packages/session-manager/src/session-manager.ts
@packages/session-manager/src/persistent-session-manager.ts
@packages/mcp-server/src/server.ts

**Tech stack available:** @modelcontextprotocol/sdk, node:child_process stdin
**Established patterns:** MCP tool registration, JSON success/error responses
**Constraining decisions:**

- [05-CONTEXT]: MCP tools are the primary interface for orchestrator
- [05-CONTEXT]: WebSocket is for dashboard UI, not orchestrator communication
- [05-CONTEXT]: Checkpoint response goes to session stdin via sendInput()

**Polling strategy note:** Orchestrator should poll gsd_get_checkpoint frequently (100-500ms) when expecting a checkpoint to minimize idle time. The tool is lightweight - just pattern matching on buffered output.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendInput method to SessionManager</name>
  <files>packages/session-manager/src/session-manager.ts, packages/session-manager/src/persistent-session-manager.ts</files>
  <action>
Add ability to write to a session's stdin pipe:

1. In SessionManager class, add sendInput method:

   ```typescript
   /**
    * Sends input to a session's stdin.
    * Used to relay checkpoint responses from orchestrator to CLI.
    * @param sessionId - ID of the session
    * @param input - Text to write to stdin (will append newline)
    * @returns true if sent, false if session not found or stdin not writable
    */
   sendInput(sessionId: string, input: string): boolean {
     const managed = this.sessions.get(sessionId);
     if (!managed?.process.stdin?.writable) {
       return false;
     }
     managed.process.stdin.write(input + '\n');
     return true;
   }
   ```

2. In PersistentSessionManager, expose the same method by delegating to inner SessionManager:
   ```typescript
   sendInput(sessionId: string, input: string): boolean {
     return this.sessionManager.sendInput(sessionId, input);
   }
   ```

This enables orchestrators to send checkpoint responses (e.g., "approved", "option-a", "done") to the Claude CLI.
</action>
<verify>TypeScript compiles: `pnpm --filter @gsd/session-manager build`</verify>
<done>sendInput() method exists on both SessionManager and PersistentSessionManager</done>
</task>

<task type="auto">
  <name>Task 2: Add gsd_respond_checkpoint MCP tool</name>
  <files>packages/mcp-server/src/tools/respond-checkpoint.ts, packages/mcp-server/src/server.ts</files>
  <action>
Create MCP tool for sending checkpoint responses:

1. Create respond-checkpoint.ts:

   ```typescript
   import { z } from 'zod';
   import type { PersistentSessionManager } from '@gsd/session-manager';

   export const respondCheckpointSchema = z.object({
     sessionId: z.string().describe('ID of the session to respond to'),
     response: z
       .string()
       .describe('Response text to send (e.g., "approved", "option-a", rejection details)'),
   });

   export type RespondCheckpointInput = z.infer<typeof respondCheckpointSchema>;

   export function createRespondCheckpointTool(manager: PersistentSessionManager) {
     return {
       name: 'gsd_respond_checkpoint',
       description:
         'Send a response to a checkpoint prompt in a GSD session. The response is written to the CLI stdin. Use after detecting a checkpoint with gsd_get_checkpoint.',
       inputSchema: respondCheckpointSchema,
       execute: async (input: RespondCheckpointInput) => {
         const { sessionId, response } = input;

         const sent = manager.sendInput(sessionId, response);

         if (!sent) {
           return {
             success: false,
             error: `Failed to send response to session ${sessionId}. Session may not exist or stdin not writable.`,
           };
         }

         return {
           success: true,
           sessionId,
           responseSent: response,
         };
       },
     };
   }
   ```

2. Register in server.ts:
   - Import createRespondCheckpointTool
   - Add to tools array alongside existing 6 tools
   - Now 7 total tools: start, list, end, output, state, checkpoint, respond_checkpoint

The tool is intentionally simple - just relay the response. The orchestrator is responsible for:

- Polling gsd_get_checkpoint to detect checkpoints
- Deciding what response to send (based on verification)
- Calling gsd_respond_checkpoint to send it
  </action>
  <verify>Build succeeds: `pnpm build` from root</verify>
  <done>gsd_respond_checkpoint tool registered and working</done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] sendInput() method works on PersistentSessionManager
- [ ] gsd_respond_checkpoint MCP tool registered (7 tools total)
- [ ] Tool returns success/error JSON response
</verification>

<success_criteria>

- sendInput() enables writing to session stdin
- gsd_respond_checkpoint MCP tool created and registered
- Tool follows existing JSON response pattern
- Build passes without errors
- Phase 5 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-integration/05-03-SUMMARY.md`
</output>
