---
phase: 05-gsd-integration
plan: 03
type: execute
---

<objective>
Enable checkpoint notifications to orchestrators and response relay back to CLI sessions.

Purpose: Complete the bidirectional communication loop - harness detects checkpoints, notifies orchestrator via WebSocket, receives response, and relays to CLI stdin.
Output: WebSocket checkpoint messages, sendInput() method on SessionManager, and response relay wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-gsd-integration/05-CONTEXT.md

# Prior work providing WebSocket infrastructure:

@.planning/phases/04-web-dashboard/04-01-SUMMARY.md

# Existing code to extend:

@packages/core/src/types/events.ts
@packages/session-manager/src/session-manager.ts
@packages/web-server/src/types.ts
@packages/web-server/src/ws-server.ts
@packages/web-server/src/harness-server.ts

**Tech stack available:** Fastify, @fastify/websocket, node:child_process stdin
**Established patterns:** SessionEvent emission, WebSocket broadcast, Set-based connection management
**Constraining decisions:**

- [05-CONTEXT]: Harness detects and relays, orchestrator handles verification locally
- [04-01]: HarnessServer as primary API, WebSocket on /ws path
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendInput method to SessionManager</name>
  <files>packages/session-manager/src/session-manager.ts, packages/session-manager/src/persistent-session-manager.ts</files>
  <action>
Add ability to write to a session's stdin pipe:

1. In SessionManager class, add sendInput method:

   ```typescript
   /**
    * Sends input to a session's stdin.
    * Used to relay checkpoint responses from orchestrator to CLI.
    * @param sessionId - ID of the session
    * @param input - Text to write to stdin (will append newline)
    * @returns true if sent, false if session not found or stdin not writable
    */
   sendInput(sessionId: string, input: string): boolean {
     const managed = this.sessions.get(sessionId);
     if (!managed?.process.stdin?.writable) {
       return false;
     }
     managed.process.stdin.write(input + '\n');
     return true;
   }
   ```

2. In PersistentSessionManager, expose the same method by delegating to inner SessionManager:
   ```typescript
   sendInput(sessionId: string, input: string): boolean {
     return this.sessionManager.sendInput(sessionId, input);
   }
   ```

This enables orchestrators to send checkpoint responses (e.g., "approved", "option-a", "done") to the Claude CLI.
</action>
<verify>TypeScript compiles: `pnpm --filter @gsd/session-manager build`</verify>
<done>sendInput() method exists on both SessionManager and PersistentSessionManager</done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket message types for checkpoint communication</name>
  <files>packages/web-server/src/types.ts, packages/core/src/types/events.ts</files>
  <action>
Add message types for bidirectional checkpoint communication:

1. In @gsd/core events.ts, ensure SessionCheckpointEvent is properly typed (already exists, verify it uses CheckpointInfo).

2. In @gsd/web-server types.ts, add new message types:

   ```typescript
   /**
    * Message from client to server: checkpoint response from orchestrator.
    */
   export interface CheckpointResponseMessage {
     type: 'checkpoint:response';
     sessionId: string;
     response: 'approved' | 'rejected' | string; // 'approved', 'rejected', or custom text
     details?: string; // Optional details (e.g., specific option selected, rejection reason)
   }

   /**
    * All WebSocket message types from client to server.
    */
   export type WsClientMessage = CheckpointResponseMessage;
   ```

3. Update WsMessage union to include checkpoint events:
   ```typescript
   export type WsMessage = SessionEventMessage | InitialStateMessage;
   // SessionEventMessage already includes SessionCheckpointEvent via SessionEvent union
   ```

The orchestrator receives session:checkpoint events and responds with checkpoint:response messages.
</action>
<verify>TypeScript compiles: `pnpm --filter @gsd/web-server build`</verify>
<done>CheckpointResponseMessage type exists, WsClientMessage union defined</done>
</task>

<task type="auto">
  <name>Task 3: Wire checkpoint response handler in HarnessServer</name>
  <files>packages/web-server/src/ws-server.ts, packages/web-server/src/harness-server.ts</files>
  <action>
Handle incoming checkpoint responses from orchestrators:

1. In WsServer, add message handler for incoming messages:

   ```typescript
   import type { WsClientMessage } from './types.js';

   // In handleConnection or equivalent:
   connection.socket.on('message', (data: Buffer) => {
     try {
       const message = JSON.parse(data.toString()) as WsClientMessage;
       this.handleClientMessage(message);
     } catch {
       // Ignore malformed messages
     }
   });

   private handleClientMessage(message: WsClientMessage): void {
     if (message.type === 'checkpoint:response') {
       this.emit('checkpoint:response', message);
     }
   }
   ```

2. In HarnessServer, wire the response to sendInput:

   ```typescript
   // In constructor or setup:
   this.wsServer.on('checkpoint:response', (message: CheckpointResponseMessage) => {
     const response = message.details ?? message.response;
     const sent = this.manager.sendInput(message.sessionId, response);
     if (!sent) {
       console.warn(`Failed to send checkpoint response to session ${message.sessionId}`);
     }
   });
   ```

3. Ensure session:checkpoint events are emitted (verify existing wiring):
   - PersistentSessionManager should emit session:checkpoint when checkpoint detected
   - This may require enhancement in session-manager if not already emitting

The flow is now: CLI outputs checkpoint -> harness detects -> broadcasts to orchestrator -> orchestrator responds -> harness relays to CLI stdin.
</action>
<verify>Build succeeds: `pnpm build` from root</verify>
<done>WebSocket handles checkpoint:response messages and relays to session stdin</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds without errors
- [ ] sendInput() method works on PersistentSessionManager
- [ ] WebSocket accepts checkpoint:response messages
- [ ] Response text is sent to session stdin
</verification>

<success_criteria>

- sendInput() enables writing to session stdin
- WebSocket message types defined for checkpoint communication
- HarnessServer wires checkpoint responses to sendInput()
- Build passes without errors
- Phase 5 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/05-gsd-integration/05-03-SUMMARY.md`
</output>
